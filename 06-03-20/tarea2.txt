su problema es usar solo series para calcular senx para x <2pi yx> 2pi, con un error absoluto en cada caso de menos de 1 parte en 10⁸. mientras que una serie infinita.


1) escriba un programa que implemente este pseudocódigo para los valores x indicados. Presente los resultados como una tabla con encabezados X IMAX SUM | SUM-SINX | / SINX, donde sinx es el valor obtenido de la función incorporada. La última columna aquí es el error relativo en su cálculo. Modifique el código que suma la serie es una "BUENA MANERA" (sin factoriales) a una que calcule la suma de una "mala manera" (factoriales explícitos).

2) producir una tabla como la anterior.
3) comience con una tolerancia de 10⁻8 como en (2.29).
4) muestre que para valores suficientemente pequeños de x, su algoritmo converge (los cambios son más pequeños que su nivel de tolerancia) y que converge a la respuesta correcta.
5) compare el número de decimales de precisión obtenidos con los esperados de ().

6) sin usar la identidad sin (x + 2npi) = sinx, demuestre que hay un rango de valores algo grandes de X para X que converge el algoritmo, pero que converge a la respuesta incorrecta.

7) demuestre que a medida que aumenta x, alcanzará un régimen en el que el algoritmo ni siquiera converge.

8) Ahora use la identidad sin (x + 2npi) = sinx para calcular sinx para valores de X grandes donde la serie de otra manera divergiría.

9) repita el cálculo utilizando la versión "incorrecta" del algoritmo (el que calcula factoriales) y compare las respuestas.

10) establezca su nivel de tolerancia en un número menor que la precisión de la máquina y vea cómo esto afecta sus conclusiones.
